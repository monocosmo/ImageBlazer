{"version":3,"sources":["../../../../src/streaming/StreamProcessor.js"],"names":["StreamProcessor","config","context","eventBus","getInstance","streamInfo","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","fragmentModel","abrController","playbackController","streamController","mediaController","textController","dashMetrics","settings","boxParser","instance","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","indexHandler","setup","resetInitialSettings","on","Events","BUFFER_LEVEL_UPDATED","onBufferLevelUpdated","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","initialize","mediaSource","create","baseURLController","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","getIsDynamic","registerStreamType","createBufferControllerForType","streamId","id","streamProcessor","reset","errored","keepBuffers","unRegisterStreamType","off","isUpdating","e","sender","getType","getStreamId","error","code","SEGMENTS_UPDATE_FAILED_ERROR_CODE","addDVRMetric","getStreamProcessor","manifest","getValue","doNotUpdateDVRWindowOnBufferUpdated","manifestInfo","isDynamic","range","calcSegmentAvailabilityRange","getCurrentRepresentation","addDVRInfo","getTime","getRepresentationController","getBuffer","setBuffer","buffer","getBufferController","getFragmentModel","updateStreamInfo","newStreamInfo","getStreamInfo","selectMediaInfo","newMediaInfo","newRealAdaptation","getRealAdaptation","voRepresentations","getVoRepresentations","realAdaptation","getData","maxQuality","getTopQualityIndexFor","minIdx","getMinAllowedIndexFor","quality","averageThroughput","bitrate","FRAGMENTED_TEXT","getThroughputHistory","getAverageThroughput","getInitialBitrateFor","getQualityForBitrate","getQualityFor","undefined","setMimeType","updateData","addMediaInfo","selectNewMediaInfo","indexOf","push","getMediaInfoArr","getMediaInfo","getMediaSource","setMediaSource","dischargePreBuffer","getScheduleController","getRepresentationInfo","voRepresentation","getRepresentationForQuality","convertDataToRepresentationInfo","isBufferingCompleted","getIsBufferingCompleted","getBufferLevel","switchInitData","representationId","bufferResetEnabled","createBuffer","previousBuffers","switchTrackAsked","controller","DashJSError","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","VIDEO","AUDIO","setIndexHandlerTime","value","setCurrentTime","getIndexHandlerTime","getCurrentTime","NaN","resetIndexHandler","resetIndex","getInitRequest","representation","getFragmentRequest","representationInfo","time","options","fragRequest","getSegmentRequestForTime","getNextSegmentRequest","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"StreamProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport DashConstants from '../dash/constants/DashConstants';\nimport BufferController from './controllers/BufferController';\nimport TextBufferController from './text/TextBufferController';\nimport ScheduleController from './controllers/ScheduleController';\nimport RepresentationController from '../dash/controllers/RepresentationController';\nimport FactoryMaker from '../core/FactoryMaker';\nimport { checkInteger } from './utils/SupervisorTools';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport DashHandler from '../dash/DashHandler';\nimport Errors from '../core/errors/Errors';\nimport DashJSError from './vo/DashJSError';\nimport Debug from '../core/Debug';\nimport RequestModifier from './utils/RequestModifier';\nimport URLUtils from '../streaming/utils/URLUtils';\n\nfunction StreamProcessor(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let streamInfo = config.streamInfo;\n    let type = config.type;\n    let errHandler = config.errHandler;\n    let mimeType = config.mimeType;\n    let timelineConverter = config.timelineConverter;\n    let adapter = config.adapter;\n    let manifestModel = config.manifestModel;\n    let mediaPlayerModel = config.mediaPlayerModel;\n    let fragmentModel = config.fragmentModel;\n    let abrController = config.abrController;\n    let playbackController = config.playbackController;\n    let streamController = config.streamController;\n    let mediaController = config.mediaController;\n    let textController = config.textController;\n    let dashMetrics = config.dashMetrics;\n    let settings = config.settings;\n    let boxParser = config.boxParser;\n\n    let instance,\n        mediaInfo,\n        mediaInfoArr,\n        bufferController,\n        scheduleController,\n        representationController,\n        indexHandler;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    }\n\n    function initialize(mediaSource) {\n        indexHandler = DashHandler(context).create({\n            streamInfo: streamInfo,\n            type: type,\n            timelineConverter: timelineConverter,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            baseURLController: config.baseURLController,\n            errHandler: errHandler,\n            settings: settings,\n            boxParser: boxParser,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors,\n            debug: Debug(context).getInstance(),\n            requestModifier: RequestModifier(context).getInstance(),\n            dashConstants: DashConstants,\n            constants: Constants,\n            urlUtils: URLUtils(context).getInstance()\n        });\n\n        // initialize controllers\n        indexHandler.initialize(playbackController.getIsDynamic());\n        abrController.registerStreamType(type, instance);\n\n        bufferController = createBufferControllerForType(type);\n        scheduleController = ScheduleController(context).create({\n            streamId: streamInfo.id,\n            type: type,\n            mimeType: mimeType,\n            adapter: adapter,\n            dashMetrics: dashMetrics,\n            timelineConverter: timelineConverter,\n            mediaPlayerModel: mediaPlayerModel,\n            fragmentModel: fragmentModel,\n            abrController: abrController,\n            playbackController: playbackController,\n            streamController: streamController,\n            textController: textController,\n            streamProcessor: instance,\n            mediaController: mediaController,\n            settings: settings\n        });\n        representationController = RepresentationController(context).create({\n            streamId: streamInfo.id,\n            type: type,\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            playbackController: playbackController,\n            timelineConverter: timelineConverter,\n            dashConstants: DashConstants,\n            events: Events,\n            eventBus: eventBus,\n            errors: Errors\n        });\n        if (bufferController) {\n            bufferController.initialize(mediaSource);\n        }\n        scheduleController.initialize();\n    }\n\n    function resetInitialSettings() {\n        mediaInfoArr = [];\n        mediaInfo = null;\n    }\n\n    function reset(errored, keepBuffers) {\n        indexHandler.reset();\n\n        if (bufferController) {\n            bufferController.reset(errored, keepBuffers);\n            bufferController = null;\n        }\n\n        if (scheduleController) {\n            scheduleController.reset();\n            scheduleController = null;\n        }\n\n        if (representationController) {\n            representationController.reset();\n            representationController = null;\n        }\n\n        if (abrController) {\n            abrController.unRegisterStreamType(type);\n        }\n\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n\n        resetInitialSettings();\n        type = null;\n        streamInfo = null;\n    }\n\n    function isUpdating() {\n        return representationController ? representationController.isUpdating() : false;\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.sender.getType() !== getType() || e.sender.getStreamId() !== streamInfo.id || !e.error || e.error.code !== Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) return;\n\n        addDVRMetric();\n    }\n\n    function onBufferLevelUpdated(e) {\n        if (e.sender.getStreamProcessor() !== instance) return;\n        let manifest = manifestModel.getValue();\n        if (!manifest.doNotUpdateDVRWindowOnBufferUpdated) {\n            addDVRMetric();\n        }\n    }\n\n    function addDVRMetric() {\n        const manifestInfo = streamInfo.manifestInfo;\n        const isDynamic = manifestInfo.isDynamic;\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getRepresentationController() {\n        return representationController;\n    }\n\n    function getBuffer() {\n        return bufferController ? bufferController.getBuffer() : null;\n    }\n\n    function setBuffer(buffer) {\n        bufferController.setBuffer(buffer);\n    }\n\n    function getBufferController() {\n        return bufferController;\n    }\n\n    function getFragmentModel() {\n        return fragmentModel;\n    }\n\n    function updateStreamInfo(newStreamInfo) {\n        streamInfo = newStreamInfo;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function selectMediaInfo(newMediaInfo) {\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\n            mediaInfo = newMediaInfo;\n        }\n\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\n\n        if (representationController) {\n            const realAdaptation = representationController.getData();\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\n            const minIdx = abrController.getMinAllowedIndexFor(type);\n\n            let quality,\n                averageThroughput;\n            let bitrate = null;\n\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\n            } else {\n                quality = abrController.getQualityFor(type);\n            }\n\n            if (minIdx !== undefined && quality < minIdx) {\n                quality = minIdx;\n            }\n            if (quality > maxQuality) {\n                quality = maxQuality;\n            }\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\n        }\n    }\n\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\n            mediaInfoArr.push(newMediaInfo);\n        }\n\n        if (selectNewMediaInfo) {\n            this.selectMediaInfo(newMediaInfo);\n        }\n    }\n\n    function getMediaInfoArr() {\n        return mediaInfoArr;\n    }\n\n    function getMediaInfo() {\n        return mediaInfo;\n    }\n\n    function getMediaSource() {\n        return bufferController.getMediaSource();\n    }\n\n    function setMediaSource(mediaSource) {\n        bufferController.setMediaSource(mediaSource, getMediaInfo());\n    }\n\n    function dischargePreBuffer() {\n        bufferController.dischargePreBuffer();\n    }\n\n    function getScheduleController() {\n        return scheduleController;\n    }\n\n    /**\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\n     * @param {number} quality - quality index of the voRepresentaion expected.\n     */\n    function getRepresentationInfo(quality) {\n        let voRepresentation;\n\n        if (quality !== undefined) {\n            checkInteger(quality);\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n        } else {\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\n        }\n\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\n    }\n\n    function isBufferingCompleted() {\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\n    }\n\n    function getBufferLevel() {\n        return bufferController ? bufferController.getBufferLevel() : 0;\n    }\n\n    function switchInitData(representationId, bufferResetEnabled) {\n        if (bufferController) {\n            bufferController.switchInitData(streamInfo.id, representationId, bufferResetEnabled);\n        }\n    }\n\n    function createBuffer(previousBuffers) {\n        return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfo, previousBuffers) : null);\n    }\n\n    function switchTrackAsked() {\n        scheduleController.switchTrackAsked();\n    }\n\n    function createBufferControllerForType(type) {\n        let controller = null;\n\n        if (!type) {\n            errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\n            return null;\n        }\n\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\n            controller = BufferController(context).create({\n                streamId: streamInfo.id,\n                type: type,\n                dashMetrics: dashMetrics,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                streamController: streamController,\n                mediaController: mediaController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                streamProcessor: instance,\n                settings: settings\n            });\n        } else {\n            controller = TextBufferController(context).create({\n                streamId: streamInfo.id,\n                type: type,\n                mimeType: mimeType,\n                dashMetrics: dashMetrics,\n                mediaPlayerModel: mediaPlayerModel,\n                manifestModel: manifestModel,\n                fragmentModel: fragmentModel,\n                errHandler: errHandler,\n                streamController: streamController,\n                mediaController: mediaController,\n                adapter: adapter,\n                textController: textController,\n                abrController: abrController,\n                playbackController: playbackController,\n                streamProcessor: instance,\n                settings: settings\n            });\n        }\n\n        return controller;\n    }\n\n    function setIndexHandlerTime(value) {\n        if (indexHandler) {\n            indexHandler.setCurrentTime(value);\n        }\n    }\n\n    function getIndexHandlerTime() {\n        return indexHandler ? indexHandler.getCurrentTime() : NaN;\n    }\n\n    function resetIndexHandler() {\n        if (indexHandler) {\n            indexHandler.resetIndex();\n        }\n    }\n\n    function getInitRequest(quality) {\n        checkInteger(quality);\n\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\n\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\n    }\n\n    function getFragmentRequest(representationInfo, time, options) {\n        let fragRequest = null;\n\n        if (indexHandler) {\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\n\n            // if time and options are undefined, it means the next segment is requested\n            // otherwise, the segment at this specific time is requested.\n            if (time !== undefined && options !== undefined) {\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\n            } else {\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\n            }\n        }\n\n        return fragRequest;\n    }\n\n    instance = {\n        initialize: initialize,\n        isUpdating: isUpdating,\n        getType: getType,\n        getBufferController: getBufferController,\n        getFragmentModel: getFragmentModel,\n        getScheduleController: getScheduleController,\n        getRepresentationController: getRepresentationController,\n        getRepresentationInfo: getRepresentationInfo,\n        getBufferLevel: getBufferLevel,\n        switchInitData: switchInitData,\n        isBufferingCompleted: isBufferingCompleted,\n        createBuffer: createBuffer,\n        updateStreamInfo: updateStreamInfo,\n        getStreamInfo: getStreamInfo,\n        selectMediaInfo: selectMediaInfo,\n        addMediaInfo: addMediaInfo,\n        switchTrackAsked: switchTrackAsked,\n        getMediaInfoArr: getMediaInfoArr,\n        getMediaInfo: getMediaInfo,\n        getMediaSource: getMediaSource,\n        setMediaSource: setMediaSource,\n        dischargePreBuffer: dischargePreBuffer,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        setIndexHandlerTime: setIndexHandlerTime,\n        getIndexHandlerTime: getIndexHandlerTime,\n        resetIndexHandler: resetIndexHandler,\n        getInitRequest: getInitRequest,\n        getFragmentRequest: getFragmentRequest,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\nexport default FactoryMaker.getClassFactory(StreamProcessor);\n"]}