{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":[],"mappings":"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","file":"BoxParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Debug from '../../core/Debug';\nimport IsoFile from './IsoFile';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ISOBoxer from 'codem-isoboxer';\n\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\n\nfunction BoxParser(/*config*/) {\n\n    let logger,\n        instance;\n    let context = this.context;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @returns {IsoFile|null}\n     * @memberof BoxParser#\n     */\n    function parse(data) {\n        if (!data) return null;\n\n        if (data.fileStart === undefined) {\n            data.fileStart = 0;\n        }\n\n        let parsedFile = ISOBoxer.parseBuffer(data);\n        let dashIsoFile = IsoFile(context).create();\n\n        dashIsoFile.setData(parsedFile);\n\n        return dashIsoFile;\n    }\n\n    /**\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\n     * @param {string[]} types\n     * @param {ArrayBuffer|uint8Array} buffer\n     * @param {number} offset\n     * @returns {IsoBoxSearchInfo}\n     * @memberof BoxParser#\n     */\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        // 8 = size (uint32) + type (4 characters)\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    function getSamplesInfo(ab) {\n        if (!ab || ab.byteLength === 0) {\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\n        }\n        let isoFile = parse(ab);\n        // zero or more moofs\n        let moofBoxes = isoFile.getBoxes('moof');\n        // exactly one mfhd per moof\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\n\n        let sampleDuration,\n            sampleCompositionTimeOffset,\n            sampleCount,\n            sampleSize,\n            sampleDts,\n            sampleList,\n            sample,\n            i, j, k, l, m, n,\n            dataOffset,\n            lastSequenceNumber,\n            numSequences,\n            totalDuration;\n\n        numSequences = isoFile.getBoxes('moof').length;\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n        sampleCount = 0;\n\n        sampleList = [];\n        let subsIndex = -1;\n        let nextSubsSample = -1;\n        for (l = 0; l < moofBoxes.length; l++) {\n            let moofBox = moofBoxes[l];\n            // zero or more trafs per moof\n            let trafBoxes = moofBox.getChildBoxes('traf');\n            for (j = 0; j < trafBoxes.length; j++) {\n                let trafBox = trafBoxes[j];\n                // exactly one tfhd per traf\n                let tfhdBox = trafBox.getChildBox('tfhd');\n                // zero or one tfdt per traf\n                let tfdtBox = trafBox.getChildBox('tfdt');\n                sampleDts = tfdtBox.baseMediaDecodeTime;\n                // zero or more truns per traf\n                let trunBoxes = trafBox.getChildBoxes('trun');\n                // zero or more subs per traf\n                let subsBoxes = trafBox.getChildBoxes('subs');\n                for (k = 0; k < trunBoxes.length; k++) {\n                    let trunBox = trunBoxes[k];\n                    sampleCount = trunBox.sample_count;\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n                    for (i = 0; i < sampleCount; i++) {\n                        sample = trunBox.samples[i];\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\n                        let sampleData = {\n                            'dts': sampleDts,\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\n                            'duration': sampleDuration,\n                            'offset': moofBox.offset + dataOffset,\n                            'size': sampleSize,\n                            'subSizes': [sampleSize]\n                        };\n                        if (subsBoxes) {\n                            for (m = 0; m < subsBoxes.length; m++) {\n                                let subsBox = subsBoxes[m];\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\n                                    subsIndex++;\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                                }\n                                if (i == nextSubsSample) {\n                                    sampleData.subSizes = [];\n                                    let entry = subsBox.entries[subsIndex];\n                                    for (n = 0; n < entry.subsample_count; n++) {\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                                    }\n                                }\n                            }\n                        }\n                        sampleList.push(sampleData);\n                        dataOffset += sampleSize;\n                        sampleDts += sampleDuration;\n                    }\n                }\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n            }\n        }\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\n    }\n\n    function getMediaTimescaleFromMoov(ab) {\n        let isoFile = parse(ab);\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n\n        return mdhdBox ? mdhdBox.timescale : NaN;\n    }\n\n    function parseUint32(data, offset) {\n        return data[offset + 3] >>> 0 |\n            (data[offset + 2] << 8) >>> 0 |\n            (data[offset + 1] << 16) >>> 0 |\n            (data[offset] << 24) >>> 0;\n    }\n\n    function parseIsoBoxType(data, offset) {\n        return String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset]);\n    }\n\n    function findInitRange(data) {\n        let initRange = null;\n        let start,\n            end;\n\n        const isoFile = parse(data);\n\n        if (!isoFile) {\n            return initRange;\n        }\n\n        const ftyp = isoFile.getBox('ftyp');\n        const moov = isoFile.getBox('moov');\n\n        logger.debug('Searching for initialization.');\n\n        if (moov && moov.isComplete) {\n            start = ftyp ? ftyp.offset : moov.offset;\n            end = moov.offset + moov.size - 1;\n            initRange = start + '-' + end;\n\n            logger.debug('Found the initialization.  Range: ' + initRange);\n        }\n\n        return initRange;\n    }\n\n    instance = {\n        parse: parse,\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n        getSamplesInfo: getSamplesInfo,\n        findInitRange: findInitRange\n    };\n\n    setup();\n\n    return instance;\n}\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexport default FactoryMaker.getSingletonFactory(BoxParser);\n"]}